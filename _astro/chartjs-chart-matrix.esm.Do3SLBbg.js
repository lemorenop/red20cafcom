import{x as E,E as O,j as M,h as d,i as S}from"./BaseChart.BPIYNeR_.js";/*!
 * chartjs-chart-matrix v2.0.1
 * https://chartjs-chart-matrix.pages.dev/
 * (c) 2023 Jukka Kurkela
 * Released under the MIT license
 */var k="2.0.1";class F extends E{static id="matrix";static version=k;static defaults={dataElementType:"matrix",animations:{numbers:{type:"number",properties:["x","y","width","height"]}}};static overrides={interaction:{mode:"nearest",intersect:!0},scales:{x:{type:"linear",offset:!0},y:{type:"linear",reverse:!0}}};initialize(){this.enableOptionSharing=!0,super.initialize()}update(t){const e=this,n=e._cachedMeta;e.updateElements(n.data,0,n.data.length,t)}updateElements(t,e,n,i){const s=this,o=i==="reset",{xScale:a,yScale:c}=s._cachedMeta,w=s.resolveDataElementOptions(e,i),y=s.getSharedOptions(i,t[e],w);for(let l=e;l<e+n;l++){const p=!o&&s.getParsed(l),x=o?a.getBasePixel():a.getPixelForValue(p.x),P=o?c.getBasePixel():c.getPixelForValue(p.y),f=s.resolveDataElementOptions(l,i),{width:g,height:b,anchorX:v,anchorY:R}=f,C={x:B(v,x,g),y:j(R,P,b),width:g,height:b,options:f};s.updateElement(t[l],l,C,i)}s.updateSharedOptions(y,i)}draw(){const t=this,e=t.getMeta().data||[];let n,i;for(n=0,i=e.length;n<i;++n)e[n].draw(t._ctx)}}function B(r,t,e){return r==="left"||r==="start"?t:r==="right"||r==="end"?t-e:t-e/2}function j(r,t,e){return r==="top"||r==="start"?t:r==="bottom"||r==="end"?t-e:t-e/2}function m(r,t){const{x:e,y:n,width:i,height:s}=r.getProps(["x","y","width","height"],t);return{left:e,top:n,right:e+i,bottom:n+s}}function h(r,t,e){return Math.max(Math.min(r,e),t)}function D(r,t,e){const n=r.options.borderWidth;let i,s,o,a;return S(n)?(i=+n.top||0,s=+n.right||0,o=+n.bottom||0,a=+n.left||0):i=s=o=a=+n||0,{t:h(i,0,e),r:h(s,0,t),b:h(o,0,e),l:h(a,0,t)}}function _(r){const t=m(r),e=t.right-t.left,n=t.bottom-t.top,i=D(r,e/2,n/2);return{outer:{x:t.left,y:t.top,w:e,h:n},inner:{x:t.left+i.l,y:t.top+i.t,w:e-i.l-i.r,h:n-i.t-i.b}}}function u(r,t,e,n){const i=t===null,s=e===null,o=!r||i&&s?!1:m(r,n);return o&&(i||t>=o.left&&t<=o.right)&&(s||e>=o.top&&e<=o.bottom)}class T extends O{static id="matrix";static defaults={backgroundColor:void 0,borderColor:void 0,borderWidth:void 0,borderRadius:0,anchorX:"center",anchorY:"center",width:20,height:20};constructor(t){super(),this.options=void 0,this.width=void 0,this.height=void 0,t&&Object.assign(this,t)}draw(t){const e=this.options,{inner:n,outer:i}=_(this),s=M(e.borderRadius);t.save(),i.w!==n.w||i.h!==n.h?(t.beginPath(),d(t,{x:i.x,y:i.y,w:i.w,h:i.h,radius:s}),d(t,{x:n.x,y:n.y,w:n.w,h:n.h,radius:s}),t.fillStyle=e.backgroundColor,t.fill(),t.fillStyle=e.borderColor,t.fill("evenodd")):(t.beginPath(),d(t,{x:n.x,y:n.y,w:n.w,h:n.h,radius:s}),t.fillStyle=e.backgroundColor,t.fill()),t.restore()}inRange(t,e,n){return u(this,t,e,n)}inXRange(t,e){return u(this,t,null,e)}inYRange(t,e){return u(this,null,t,e)}getCenterPoint(t){const{x:e,y:n,width:i,height:s}=this.getProps(["x","y","width","height"],t);return{x:e+i/2,y:n+s/2}}tooltipPosition(){return this.getCenterPoint()}getRange(t){return t==="x"?this.width/2:this.height/2}}export{F as M,T as a};
